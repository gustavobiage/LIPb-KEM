

# This file was *autogenerated* from the file KEM.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_16 = Integer(16); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_1024 = Integer(1024); _sage_const_256 = Integer(256); _sage_const_50 = Integer(50); _sage_const_10en7 = RealNumber('10e-7'); _sage_const_3 = Integer(3); _sage_const_9 = Integer(9)
import os
from sage.stats.distributions.discrete_gaussian_lattice import DiscreteGaussianDistributionLatticeSampler
import sage.matrix.matrix_integer_dense_hnf as HNF

from sage.misc.trace import trace

os.system('sage --preparse Utils.sage')
os.system('mv Utils.sage.py Utils.py')
import Utils as Utils

os.system('sage --preparse QFUtils.sage')
os.system('mv QFUtils.sage.py QFUtils.py')
import QFUtils as QFUtils

os.system('sage --preparse BW.sage')
os.system('mv BW.sage.py BW.py')
import BW as BW

class LatticePair:

	def __init__(self, B, shortest_vector_length, decoding_distance):
		self.shortest_vector_length = shortest_vector_length
		self.decoding_distance = decoding_distance
		self.BQ, self.BS, self.g = self.__build_pair(B, shortest_vector_length)
		self.s, self.q = self.__compute_parameters(self.BQ, shortest_vector_length, decoding_distance)
		self.SIS = self.__compute_SIS_parameters(self.BQ, self.q, decoding_distance)

	def __build_pair(self, B, shortest_vector_length):
		gap = Utils.IntegralLatticeGap(B, shortest_vector_length)
		g = ZZ(ceil(min(gap**_sage_const_2 , _sage_const_16  * sqrt(_sage_const_2 ))))

		BQ = block_matrix([[B,				 _sage_const_0 ],
						   [_sage_const_0 ,   g*(g + _sage_const_1 ) * B]])
		BS = block_matrix([[g * B,			 _sage_const_0 ],
						   [	_sage_const_0 , (g + _sage_const_1 ) * B]])

		return (BS, BQ, g)

	def __compute_parameters(self, B, shortest_vector_length, decoding_distance):
		N, N = B.dimensions()
		S = B.transpose() * B
		BSstar = Utils.GramSchmidt(B)

		s_ = max(v.norm() for v in BSstar) * sqrt(ln(_sage_const_2  * N + _sage_const_4 )/pi)
		s = ZZ(ceil(max(shortest_vector_length, s_)))

		q_ = (s * N) / decoding_distance * sqrt(ln(_sage_const_2  * N + _sage_const_4 ) / pi)
		q = ZZ(ceil(q_))

		return (s, q)

	def __compute_SIS_parameters(self, B, q, decoding_distance):
		N, N = B.dimensions()

		# extractor function dimension 'm'. Values were chose so that 'l' is 'theta(n)'' bouded.
		M = ZZ(ceil(sqrt(N)))

		# extractor function moduli (TODO)
		# q_ = next_prime(ceil(2*q*rho * sqrt(n * log(n))))
		moduli = next_prime(floor(_sage_const_2 **(N/M + M)))

		beta = _sage_const_2  * q * decoding_distance
		return (M, N, moduli, beta)

	def PublicKeySize(self):
		N, N = self.BQ.dimensions()
		# This is the maximum length of the vectors in the generating set S
		lenS = self.s * sqrt(N)

		inBytes = _sage_const_0 
		for i in range(N):
			for j in range(i+_sage_const_1 ):
				# These are the length of the i-th vector and j-th vector in the basis R that generates the Gram Matrix of the public key
				lenA = max(sqrt(i)/_sage_const_2  * lenS, lenS)
				lenB = max(sqrt(j)/_sage_const_2  * lenS, lenS)
				# By definition of Gram Matrix, G(i, j) = < R(i), R(j) > <= |R(i)| * |R(j)|
				inBytes += ZZ(ceil(log(lenA * lenB, _sage_const_2 )))

		print("PK", float(inBytes), "b")
		inBytes = inBytes / _sage_const_8 
		print("PK", float(inBytes), "B")
		inBytes = inBytes / _sage_const_1024 
		print("PK", float(inBytes), "KB")
		inBytes = inBytes / _sage_const_1024 
		print("PK", float(inBytes), "MB")
		inBytes = inBytes / _sage_const_1024 
		print("PK", float(inBytes), "GB")
		return inBytes

	def SecretKeySize(self):
		N, N = self.BQ.dimensions()
		# This is the maximum length of the vectors in the generating set S
		lenS = self.s * sqrt(N)

		inBytes = N * ZZ(ceil(log(lenS, _sage_const_2 )))
		print("SK", float(inBytes), "b")
		inBytes = inBytes / _sage_const_8 
		print("SK", float(inBytes), "B")
		inBytes = inBytes / _sage_const_1024 
		print("SK", float(inBytes), "KB")
		inBytes = inBytes / _sage_const_1024 
		print("SK", float(inBytes), "MB")
		inBytes = inBytes / _sage_const_1024 
		print("SK", float(inBytes), "GB")

	def EncapsulatedKeySize(self):
		N, N = self.BQ.dimensions()
		# This is the maximum length of the vectors in the generating set S

		inBytes = N * ZZ(ceil(log(self.q, _sage_const_2 ))) + _sage_const_256 
		print("CH", float(inBytes), "b")
		inBytes = inBytes / _sage_const_8 
		print("CH", float(inBytes), "B")
		inBytes = inBytes / _sage_const_1024 
		print("CH", float(inBytes), "KB")
		inBytes = inBytes / _sage_const_1024 
		print("CH", float(inBytes), "MB")
		inBytes = inBytes / _sage_const_1024 
		print("CH", float(inBytes), "GB")

	def EstimateBDDHardness(self):
		N, N = self.BQ.dimensions()
		det = self.LargestDeterminantInSUVPReduction(self.BQ, self.decoding_distance)
		beta = self.EstimateBetaForSUVP(det, N + _sage_const_1 )
		print("BETA", beta)

	def LargestDeterminantInSUVPReduction(self, B, rho):
		return B.det() * rho

	def EstimateBetaForSUVP(self, det, dim):
		for b in range(_sage_const_50 , dim):
			delta = ((pi * b)**(_sage_const_1 /b) *(b/(_sage_const_2  * pi * e)))**(_sage_const_1 /(_sage_const_2 *b - _sage_const_2 ))
			eq1 = sqrt(b)
			eq2 = delta**(_sage_const_2 *b - dim - _sage_const_1 ) * det**(_sage_const_1  / dim)
			if self.Compare(eq1, eq2, _sage_const_10en7 ) < _sage_const_1 :
				return b
		return dim

	def Compare(self, a, b, epsilon):
		if abs(a - b) <= epsilon:
			return _sage_const_0 

		if a < b:
			return -_sage_const_1 

		return _sage_const_1 

class KEM:

	def __init__(self, latticePair):
		self.latticePair = latticePair

	def NearestPlane(B, t):
		B = Utils.LLL(B, _sage_const_3 /_sage_const_4 ) # Delta = 3/4
		N, M = B.dimensions()
		b = t
		for j in range(M-_sage_const_1 , -_sage_const_1 , -_sage_const_1 ):
			c = round(b.dot_product(B.column(j)) / Utils.Norm2(B.column(j)))
			b = b - c * B.column(j)
		return t - b

	def SampleQuadraticForm(B, s):
		print("SampleQuadraticForm")
		N, N  = B.dimensions()
		C = _sage_const_1  - (_sage_const_1  + exp(-pi))**(-_sage_const_1 )
		m = ceil(_sage_const_2 *N / C)
		c = zero_vector(ZZ, N)

		#time S = matrix(ZZ, m, N, [KEM.SampleD(B, s, c) for _ in range(m)]).transpose()
		D = DiscreteGaussianDistributionLatticeSampler(B.transpose(), s, zero_vector(N))
		S = matrix(ZZ, m, N, [D() for _ in range(m)]).transpose()

		if S.rank() < N:
			return KEM.SampleQuadraticForm(B, s)

		S = KEM.Simplify(S)
		S = Utils.SortByColumnNorm(S)
		R, U = KEM.Extract(B, S)
		return (R, U, S)

	def Simplify(S):
		"""
			Let S be an set of N-dimensional vectors in L(B) ordered by norm
			and with rank N.

			We select the first N linearly independent of vectors from S such
			that |s1| <= |s2| <= ... <= |sN|.
		"""
		N, M = S.dimensions()
		assert N > _sage_const_0 
		S_ = matrix(ZZ, N, _sage_const_0 )
		
		for column in S.columns():
			aux = block_matrix([[S_, matrix(column).transpose()]])

			if aux.rank() > S_.rank():
				S_ = aux

			if S_.rank() == N:
				return S_

		assert S.rank() == N

	def Extract(B, S):
		print("Extract")
		N, M = S.dimensions()

		Q = matrix(ZZ, B.inverse() * S)
		T, U_ = HNF.hnf_with_transformation(Q)

		U = matrix(ZZ, U_.inverse())
		R = B * U

		assert S == R * T
		S_ = Utils.GramSchmidt(S)

		for k in range(N):
			s = S.column(k)
			r = R.column(k)

			if Utils.Norm2(r) <= max((k+_sage_const_1 )/_sage_const_4 , _sage_const_1 ) * Utils.Norm2(s):
				continue

			R_ = Utils.GramSchmidt(R)
			assert all(R_.column(i).norm() <= S_.column(i).norm() for i in range(N))

			r_ = R_.column(k)
			s_ = S_.column(k)

			if r_ == s_ or r_ == -s_:
				Utils.InsertColumn(R, k, s)
			else:
				x = r - r_ # Projection
				BR = block_matrix([[matrix(R.column(i)).transpose() for i in range(k)]])

				v = KEM.NearestPlane(BR, x)
				assert Utils.Norm2(x - v) <= (N-_sage_const_1 ) * max(Utils.Norm2(s) for s in S.columns())/_sage_const_4 
				assert Utils.Norm2(r - v) <= max(((k+_sage_const_1 )/_sage_const_4 ), _sage_const_1 ) * Utils.Norm2(s)

				Utils.InsertColumn(R, k, r - v)

		# Since we modified vectors in R, we must recompute U such that R = B * U
		U = matrix(ZZ, N, N, B.inverse() * R)
		return (R.transpose() * R, U)

	def GenerateKeyPair(self):
		print("GENERATE")
		B = self.latticePair.BQ
		s = self.latticePair.s
		R, U, S = KEM.SampleQuadraticForm(B, s)
		assert U.det() == _sage_const_1  or U.det() == -_sage_const_1 
		assert R.rank() == B.rank()
		return (R, S)

	def SampleA(seed, N, M, Ring):
		set_random_seed(seed)
		M = random_matrix(Ring, N, M)
		set_random_seed()
		return M

	def EncapsulateKey(self, public_key):
		print("ENCAPSULATE")
		P = public_key
		q = self.latticePair.q
		rho = self.latticePair.decoding_distance
		SISm, _, SISq, _ = self.latticePair.SIS

		N, N = P.dimensions()
		s_ = (q * rho) / sqrt(N)
		e_ = QFUtils.SampleD(P, s_)
		e = e_ / q
		assert QFUtils.Norm2(P, e) <= rho*rho

		c = vector(QQ, N, [QQ((x.numerator() % x.denominator()) / x.denominator()) for x in e])

		seed = randint(_sage_const_0 , _sage_const_256 )

		Ring = IntegerModRing(SISq)
		A = KEM.SampleA(seed, SISm, N, Ring)

		# We must multiply the result by the inverse modular of
		# the determinant of BP^T (mod SISq).
		determinant = sqrt(P.det())
		determinant = Ring(determinant)
		k = ((A * P) * e_) / determinant

		return ((c, seed), k)

	def DecapsulateKey(self, secret_key, encapsulatedKey):
		print("DECAPSULATE")
		c, seed = encapsulatedKey
		S = secret_key

		# Utils information
		BQ = self.latticePair.BQ
		q = self.latticePair.q
		g = self.latticePair.g
		rho = self.latticePair.decoding_distance
		SISm, _, SISq, _ = self.latticePair.SIS

		# Extract secret uniform transformation
		P, U = KEM.Extract(BQ, S)

		# U*c returns the coefficients of the vector we must decode.
		# By multiplying it by BQ, we obtain the actual vector.
		v = (BQ * U) * c

		# Since BW is implemented using Gaussian Integers, we must convert
		# the vectors back and forward between ZZ and GG
		# (Analogue, error vectors contain rationals and must be converted to CC)
		v1 = BW.VectorOverCC(v[_sage_const_0 :N/_sage_const_2 ])
		v2 = BW.VectorOverCC(vector(v[N/_sage_const_2 :N]) / (g * (g + _sage_const_1 )))


		y1 = BW.VectorOverZZ(BW.SeqBW(_sage_const_0 , v1))
		y2 = BW.VectorOverZZ(BW.SeqBW(_sage_const_0 , v2))

		# Compute decoded vector, as defined by the lattice pair.
		y = vector(ZZ, N, list(y1) + list(y2 * (g * (g + _sage_const_1 ))))
		
		assert Utils.isLatticeVector(BQ, y)

		# Reconstruct encapsulated key from extractor
		x = c - (U.inverse() * Utils.Coeff(BQ, y))
		x_ = vector(ZZ, q * x)
		assert Utils.Norm2(y - v) <= rho*rho

		Ring = IntegerModRing(SISq)
		A = KEM.SampleA(seed, SISm, N, Ring)

		Q = BQ.transpose() * BQ
		P = U.transpose() * Q * U
		
		determinant = sqrt(P.det())
		determinant = Ring(determinant)
		k = ((A * P) * x_) / determinant

		# Return key
		return k

for i in range(_sage_const_1 , _sage_const_9 ):
	B, shortest_vector_length, decoding_distance = BW.BarnesWall(i)
	B = BW.BasisOverZZ(B)
	latticePair = LatticePair(B, shortest_vector_length, decoding_distance)
	print(latticePair.BQ.dimensions())
	latticePair.PublicKeySize()
	latticePair.SecretKeySize()
	latticePair.EncapsulatedKeySize()
	latticePair.EstimateBDDHardness()
	print("=====================")

# B, shortest_vector_length, decoding_distance = BW.BarnesWall(4)
# B = BW.BasisOverZZ(B)
# latticePair = LatticePair(B, shortest_vector_length, decoding_distance)
# N, N = latticePair.BQ.dimensions()
# kem = KEM(latticePair)
# while True:
# 	pk, sk = kem.GenerateKeyPair()
# 	ch, k = kem.EncapsulateKey(pk)
# 	k2 = kem.DecapsulateKey(sk, ch)
# 	assert k == k2

#trace("LatticePair(B, shortest_vector_length, decoding_distance)")             # not tested
#time LatticePair(B, shortest_vector_length, decoding_distance)




# N, N = latticePair.BQ.dimensions()
# print("N", N)
# latticePair.PublicKeySize()
# latticePair.SecretKeySize()
# latticePair.EncapsulatedKeySize()
# latticePair.EstimateBDDHardness()

# kem = KEM(latticePair)
# pk, sk = kem.GenerateKeyPair()
# print("pk")
# print(pk)
# print("sk")
# print(sk)
# ch, k = kem.EncapsulateKey(pk)
# k = kem.DecapsulateKey(sk, ch)
# print("+------------------------------------_+")



# s = latticePair.s
# N, N = B.dimensions()
# S = matrix(ZZ, N, N, [[ 1,  1,  0, -1],
# 					  [ 1,  0, -1,  1],
# 					  [ 0, -1,  1,  1],
# 					  [ 0, -1,  1, -1]])
# KEM.Extract(B, S)

# S = matrix(ZZ, N, N, [[-2,-3,-2, 3],
# 					  [ 0, 1, 4,-1],
# 					  [-2, 2, 0,-2],
# 					  [ 0, 0, 0,-4]])
# KEM.Extract(B, S)

# S = matrix(ZZ, N, N, [[ -9, 11, -5, -9],
# 					  [ -6,  8, 18,-13],
# 					  [  3,  6, -7, 17],
# 					  [ -3,  2,  7, 11]])

# KEM.Extract(B, S)
# for _ in range(20000):
#  	R = KEM.SampleQuadraticForm(latticePair.BQ, s)

# kem = KEM(latticePair)

# print(latticePair.BQ)

# pk, sk = kem.GenerateKeyPair()
# encap, k = kem.EncapsulateKey(pk)
# k = kem.DecapsulateKey(sk, encap)

