

# This file was *autogenerated* from the file BW.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_10 = Integer(10); _sage_const_3 = Integer(3)
os.system('sage --preparse Utils.sage')
os.system('mv Utils.sage.py Utils.py')
import Utils as Utils

# Gaussian Integers
GG = ZZ[I]
GQ = QQ[I]
PHI = GG(_sage_const_1  + I)

def KroneckerProduct(A, B):
	m, n = A.dimensions()
	p, q = B.dimensions()
	return block_matrix([[A[i, j] * B for j in range(n)] for i in range(m)], subdivide=False);

# def BarnesWall(n):
# 	 if n == 0:
# 		 return matrix(GG, 1, [GG(1)])

# 	 return block_matrix([[ BarnesWall(n-1), BarnesWall(n-1)],
# 						  [0, PHI * BarnesWall(n-1)]])

def BarnesWall(n):
	BW = matrix(GG, _sage_const_2 , _sage_const_2 , [[_sage_const_1 ,	 _sage_const_1 ],
					   	   [_sage_const_0 , _sage_const_1  + i]]);

	BWN = BW
	for _ in range(n-_sage_const_1 ):
		BWN = KroneckerProduct(BWN, BW)

	N, N = BWN.dimensions()
	return (BWN, sqrt(N), sqrt(N)/_sage_const_4 )

def BWvector(B, LOWER_BOUND=-_sage_const_10 , UPPER_BOUND=_sage_const_10 ):
	N, N = B.dimensions()
	coeff = vector(GG, N, [(ZZ(randint(LOWER_BOUND, UPPER_BOUND)) + I*ZZ(randint(LOWER_BOUND, UPPER_BOUND))) for _ in range(N)])
	return B*coeff

def BasisOverZZ(B):
	N, N = B.dimensions()
	return block_matrix([[ matrix(ZZ, _sage_const_2 , _sage_const_2 , [[ZZ(   R(B[i, j])), ZZ(Img(B[i, j]))],
											 [ZZ(-Img(B[i, j])), ZZ(  R(B[i, j]))]]) for j in range(N)] for i in range(N)], subdivide=False);

def VectorOverCC(v):
	N = len(v)
	return vector(CC, [CC(v[i+_sage_const_1 ] + v[i] * I) for i in range(_sage_const_0 , N-_sage_const_1 , _sage_const_2 )])

def VectorOverGG(v):
	N = len(v)
	return vector(GG, [GG(v[i+_sage_const_1 ] + v[i] * I) for i in range(_sage_const_0 , N-_sage_const_1 , _sage_const_2 )])

def VectorOverZZ(v):
	N = len(v)
	return vector(ZZ, block_matrix([ [ matrix(ZZ, _sage_const_1 , _sage_const_2 , [[ZZ(Img(x)), ZZ(  R(x))]]) for x in v]])[_sage_const_0 ])

def isBWvector(B, v):
	N, N = B.dimensions()
	BZ = BasisOverZZ(B)
	vz = VectorOverZZ(v)
	return Utils.isLatticeVector(B, v)

def Error(B):
	N, N = B.dimensions()
	
	dmin2 = N/_sage_const_4  # Minimum correction distance squared
	errorbound = RR(sqrt(dmin2)/_sage_const_3 )

	# First we sample a simple vector in the form (error, 0, ..., 0).
	simple_error = vector(QQ, _sage_const_2 *N, [_sage_const_0  if i != _sage_const_0  else random()*errorbound for i in range(_sage_const_2 *N)])
	return vector(CC, N, [(simple_error[i+_sage_const_1 ] + I * simple_error[i]) for i in range(_sage_const_0 , _sage_const_2 *N, _sage_const_2 )])

	# Then, we sample a random rotation using the QR decomposition of a random matrix.
	G = MatrixSpace(RDF, _sage_const_2 *N)
	M = G.random_element()
	Q, R = M.QR()
	# We compute the real erro by "rotating" the simples error.
	real_vector = Q*simple_error

	# Finally, we convert the error on RR^N to CC^N.
	return vector(CC, N, [(real_vector[i+_sage_const_1 ] + I * real_vector[i]) for i in range(_sage_const_0 , _sage_const_2 *N, _sage_const_2 )])

def ParBW(p, s):
	N = len(s)
	if p < _sage_const_4  or N == _sage_const_1 :
		return SeqBW(_sage_const_0 , s)

	terms = list(s)
	s0 = vector(GQ, terms[_sage_const_0 :N/_sage_const_2 ])
	s1 = vector(GQ, terms[N/_sage_const_2 :N])
	PHI_2 = GQ(PHI/_sage_const_2 )
	sm = PHI_2 * (s0 - s1)
	sp = PHI_2 * (s0 + s1)

	z0 = ParBW(p/_sage_const_4 , s0)
	z1 = ParBW(p/_sage_const_4 , s1)
	zm = ParBW(p/_sage_const_4 , sm)
	zp = ParBW(p/_sage_const_4 , sp)

	INVERSE_PHI = PHI.inverse()
	z0m = vector(GG, N, list(z0) + list(z0 - GG(_sage_const_2 *INVERSE_PHI) * zm));
	z0p = vector(GG, N, list(z0) + list(GG(_sage_const_2 *INVERSE_PHI)*zp - z0))
	z1m = vector(GG, N, list(GG(_sage_const_2 *INVERSE_PHI)*zm + z1) + list(z1))
	z1p = vector(GG, N, list(GG(_sage_const_2 *INVERSE_PHI)*zp - z1) + list(z1))

	arr = [z0m, z0p, z1m, z1p]
	return min(((s - v).norm(_sage_const_2 ), v) for v in arr)[_sage_const_1 ]

def RoundZZ(r):
	return ZZ(round(r))

def RoundGG(c):
	return GG(RoundZZ(c[_sage_const_0 ]) + I * RoundZZ(c[_sage_const_1 ]))

def Frac(r):
	return QQ(abs(r - RoundZZ(r)))

def R(c):
	return c[_sage_const_0 ]

def Img(c):
	return c[_sage_const_1 ]

def SeqBW(r, s):
	N = len(s)

	if N <= _sage_const_2 **r:
		return vector(GG, [RoundGG(t) for t in s])

	b = vector(GF(_sage_const_2 ), [GF(_sage_const_2 )(RoundZZ(R(t)) + RoundZZ(Img(t))) for t in s])
	rho = vector(QQ, [QQ(_sage_const_1  - _sage_const_2 *max(Frac(R(t)), Frac(Img(t)))) for t in s])

	t = list([(b[i], rho[i]) for i in range(N)])
	PSIc = RMDec(r, t)

	INVERSE_PHI = GQ(PHI.inverse())
	v = SeqBW(r + _sage_const_1 , (s - PSIc) * INVERSE_PHI)
	return PSIc + (PHI * v)

def B(t):
	return t[_sage_const_0 ]

def Rho(t):
	return t[_sage_const_1 ]

def Eval(exp):
	return GF(_sage_const_2 )(_sage_const_1 ) if exp else GF(_sage_const_2 )(_sage_const_0 )

def RMDec(r, t):
	# print("RMDec", t, r)
	N = len(t)
	if r == _sage_const_0  or N == _sage_const_2 **r:
		return vector(ZZ, N, [ZZ(B(x)) for x in t])
	else:
		t0 = t[_sage_const_0 :N/_sage_const_2 ]
		t1 = t[N/_sage_const_2 :N]
		tp = [_sage_const_0 ]*int(N/_sage_const_2 )
		for j in range(N/_sage_const_2 ):
			tp[j] = (B(t0[j]) + B(t1[j]), min(Rho(t0[j]), Rho(t1[j])))
		v = RMDec(r-_sage_const_1 , tp)

		tm = [_sage_const_0 ]*int(N/_sage_const_2 )
		for j in range(N/_sage_const_2 ):
			if (B(t0[j]) + B(t1[j])) == (v[j] % _sage_const_2 ):
				tm[j] = (B(t0[j]), QQ((Rho(t0[j]) + Rho(t1[j])) / _sage_const_2 ))
			else:
				tm[j] = (B(t0[j]) + Eval(Rho(t0[j]) < Rho(t1[j])), QQ(abs(Rho(t0[j]) - Rho(t1[j]))/_sage_const_2 ))

		u = RMDec(r, tm)
		return vector(ZZ, list(u) + list(u + v))

# tries = 10
# while tries > 0:
# 	tries = tries - 1

# 	BW, shortest_vector_length, rho = BarnesWall(5)
# 	N, N = BW.dimensions()

# 	BWZ = Utils.SortByColumnNorm(BasisOverZZ(BW))

# 	s_ = max(v.norm() for v in Utils.GramSchmidt(BWZ)) * sqrt(ln(2 * 2 * N + 4)/pi)
# 	s = ZZ(ceil(max(shortest_vector_length, s_)))

# 	q_ = (s * N) / rho * sqrt(ln(2 * 2 * N + 4) / pi)
# 	q = ZZ(ceil(q_))

# 	standard_deviation = (q * rho) / sqrt(N)
# 	c = zero_vector(ZZ, 2 * N)
# 	error = VectorOverCC(Utils.SampleD(BWZ, standard_deviation, c) / q)
# 	print(error)
# 	#error = Error(BW)
# 	#error = vector(GQ, 2, [QQ(1/5), 0])
# 	#error = vector(GQ, 2, [QQ(1/100), 0])
# 	#error = vector(GQ, N, [QQ(1/5)] + [0 for _ in range(N-1)])
# 	assert error.norm()^2 < N/4 # Error must be decodable

# 	bwvector = BWvector(BW) # Sample random vector in BW
# 	#bwvector = vector(GG, 2, [9*I - 5, 5*I - 9])
# 	#bwvector = vector(GG, 2, [12*I - 1, -2*I - 16])
# 	#bwvector = vector(GG, 4, [-15*I + 20, -I + 9, -5*I + 13, -6*I + 4])
	# assert Utils.isBWvector(BW, bwvector)

# 	decodable_vector = bwvector + error
# 	bwvector2 = ParBW(1, decodable_vector)
# 	# print(bwvector)
# 	# print(bwvector2)
# 	assert bwvector == bwvector2

